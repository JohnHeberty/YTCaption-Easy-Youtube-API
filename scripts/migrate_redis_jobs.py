#!/usr/bin/env python3
"""
Script de migra√ß√£o para normalizar timestamps de jobs no Redis.

Busca todos os jobs armazenados no Redis e normaliza campos datetime
de naive para timezone-aware (America/Sao_Paulo).

Uso:
    python migrate_redis_jobs.py --dry-run      # Mostra o que seria feito
    python migrate_redis_jobs.py --execute      # Executa a migra√ß√£o
    python migrate_redis_jobs.py --stats        # Mostra apenas estat√≠sticas

Author: Generated by GitHub Copilot
Date: 2026-02-28
"""
import argparse
import json
import sys
from datetime import datetime
from typing import Dict, List, Tuple
from zoneinfo import ZoneInfo

try:
    import redis
except ImportError:
    print("‚ùå Erro: redis-py n√£o instalado")
    print("   Instale com: pip install redis")
    sys.exit(1)


# Configura√ß√µes
BRAZIL_TZ = ZoneInfo("America/Sao_Paulo")
REDIS_HOST = "localhost"
REDIS_PORT = 6379
REDIS_DB = 0
REDIS_PATTERN = "job:*"  # Pattern para buscar jobs

# Campos datetime que precisam ser normalizados
DATETIME_FIELDS = [
    "created_at",
    "updated_at",
    "completed_at",
    "started_at",
    "expires_at",
    "failed_at"
]


class JobMigrator:
    """Migrador de jobs no Redis"""
    
    def __init__(self, host: str = REDIS_HOST, port: int = REDIS_PORT, db: int = REDIS_DB):
        """
        Inicializa conex√£o com Redis
        
        Args:
            host: Redis host
            port: Redis port
            db: Redis database number
        """
        self.client = redis.Redis(
            host=host,
            port=port,
            db=db,
            decode_responses=True
        )
        self.stats = {
            "total_jobs": 0,
            "jobs_migrated": 0,
            "jobs_skipped": 0,
            "jobs_error": 0,
            "fields_normalized": 0
        }
    
    def get_all_jobs(self) -> List[str]:
        """
        Busca todas as chaves de jobs no Redis
        
        Returns:
            Lista de chaves de jobs
        """
        return self.client.keys(REDIS_PATTERN)
    
    def parse_datetime(self, dt_str: str) -> datetime:
        """
        Converte string ISO para datetime
        
        Args:
            dt_str: String datetime em formato ISO
            
        Returns:
            Datetime object
        """
        # Remove timezone info se presente (para detectar naive/aware)
        if dt_str.endswith('Z'):
            dt_str = dt_str[:-1] + '+00:00'
        
        try:
            dt = datetime.fromisoformat(dt_str)
        except ValueError:
            # Fallback: tenta formatos alternativos
            dt = datetime.strptime(dt_str, "%Y-%m-%dT%H:%M:%S.%f")
        
        return dt
    
    def is_naive(self, dt: datetime) -> bool:
        """
        Verifica se datetime √© naive (sem timezone)
        
        Args:
            dt: Datetime object
            
        Returns:
            True se naive, False se aware
        """
        return dt.tzinfo is None or dt.tzinfo.utcoffset(dt) is None
    
    def normalize_datetime(self, dt: datetime) -> datetime:
        """
        Normaliza datetime para timezone-aware (Bras√≠lia)
        
        Args:
            dt: Datetime possivelmente naive
            
        Returns:
            Datetime timezone-aware
        """
        if self.is_naive(dt):
            # Assume que naive datetime est√° em hor√°rio de Bras√≠lia
            return dt.replace(tzinfo=BRAZIL_TZ)
        return dt
    
    def migrate_job(self, key: str, dry_run: bool = True) -> Tuple[bool, int]:
        """
        Migra um job espec√≠fico
        
        Args:
            key: Chave do job no Redis
            dry_run: Se True, apenas simula
            
        Returns:
            (sucesso, quantidade de campos normalizados)
        """
        try:
            # L√™ job do Redis
            job_str = self.client.get(key)
            if not job_str:
                return False, 0
            
            job_data = json.loads(job_str)
            fields_normalized = 0
            
            # Normaliza cada campo datetime
            for field in DATETIME_FIELDS:
                if field in job_data and job_data[field]:
                    try:
                        dt = self.parse_datetime(job_data[field])
                        
                        if self.is_naive(dt):
                            # Normaliza para timezone-aware
                            normalized_dt = self.normalize_datetime(dt)
                            job_data[field] = normalized_dt.isoformat()
                            fields_normalized += 1
                    
                    except (ValueError, AttributeError) as e:
                        print(f"‚ö†Ô∏è  Erro parseando {field} em {key}: {e}")
                        continue
            
            # Se encontrou campos para normalizar, salva de volta
            if fields_normalized > 0:
                if not dry_run:
                    self.client.set(key, json.dumps(job_data))
                return True, fields_normalized
            
            return False, 0
        
        except Exception as e:
            print(f"‚ùå Erro migrando {key}: {e}")
            return False, 0
    
    def run_migration(self, dry_run: bool = True) -> Dict:
        """
        Executa migra√ß√£o em todos os jobs
        
        Args:
            dry_run: Se True, apenas simula
            
        Returns:
            Dicion√°rio com estat√≠sticas
        """
        print(f"\n{'üîç DRY RUN' if dry_run else '‚ö° EXECUTANDO'} - Migra√ß√£o de Jobs Redis")
        print(f"üìä Buscando jobs com pattern: {REDIS_PATTERN}")
        
        job_keys = self.get_all_jobs()
        self.stats["total_jobs"] = len(job_keys)
        
        print(f"‚úÖ Encontrados: {self.stats['total_jobs']} jobs\n")
        
        if self.stats["total_jobs"] == 0:
            print("‚ö†Ô∏è  Nenhum job encontrado")
            return self.stats
        
        # Migra cada job
        for i, key in enumerate(job_keys, 1):
            migrated, fields_count = self.migrate_job(key, dry_run=dry_run)
            
            if migrated:
                self.stats["jobs_migrated"] += 1
                self.stats["fields_normalized"] += fields_count
                status = "‚úì" if not dry_run else "‚ûú"
                print(f"{status} [{i}/{self.stats['total_jobs']}] {key}: {fields_count} campos")
            else:
                self.stats["jobs_skipped"] += 1
        
        return self.stats
    
    def show_stats(self):
        """Exibe estat√≠sticas da migra√ß√£o"""
        print("\n" + "="*60)
        print("üìä ESTAT√çSTICAS DA MIGRA√á√ÉO")
        print("="*60)
        print(f"Total de jobs:           {self.stats['total_jobs']}")
        print(f"Jobs migrados:           {self.stats['jobs_migrated']}")
        print(f"Jobs j√° corretos:        {self.stats['jobs_skipped']}")
        print(f"Jobs com erro:           {self.stats['jobs_error']}")
        print(f"Campos normalizados:     {self.stats['fields_normalized']}")
        print("="*60)
        
        if self.stats["jobs_migrated"] > 0:
            percent = (self.stats["jobs_migrated"] / self.stats["total_jobs"]) * 100
            print(f"\n‚úÖ {percent:.1f}% dos jobs precisaram de normaliza√ß√£o")
        else:
            print("\n‚úÖ Todos os jobs j√° est√£o com timezone correto!")


def main():
    """Main function"""
    parser = argparse.ArgumentParser(
        description="Migra√ß√£o de timestamps no Redis (naive ‚Üí timezone-aware)"
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Modo simula√ß√£o (n√£o altera dados)"
    )
    parser.add_argument(
        "--execute",
        action="store_true",
        help="Executa a migra√ß√£o (altera dados)"
    )
    parser.add_argument(
        "--stats",
        action="store_true",
        help="Apenas mostra estat√≠sticas"
    )
    parser.add_argument(
        "--host",
        default=REDIS_HOST,
        help=f"Redis host (default: {REDIS_HOST})"
    )
    parser.add_argument(
        "--port",
        type=int,
        default=REDIS_PORT,
        help=f"Redis port (default: {REDIS_PORT})"
    )
    parser.add_argument(
        "--db",
        type=int,
        default=REDIS_DB,
        help=f"Redis database (default: {REDIS_DB})"
    )
    
    args = parser.parse_args()
    
    # Valida√ß√£o: precisa escolher um modo
    if not (args.dry_run or args.execute or args.stats):
        parser.print_help()
        print("\n‚ùå Erro: Escolha um modo (--dry-run, --execute ou --stats)")
        sys.exit(1)
    
    try:
        # Cria migrador
        migrator = JobMigrator(host=args.host, port=args.port, db=args.db)
        
        # Testa conex√£o
        migrator.client.ping()
        print(f"‚úÖ Conectado ao Redis: {args.host}:{args.port} (db={args.db})")
        
        # Executa migra√ß√£o
        if args.stats:
            # Apenas estat√≠sticas (dry-run sem output de cada job)
            migrator.run_migration(dry_run=True)
        else:
            migrator.run_migration(dry_run=args.dry_run)
        
        # Exibe estat√≠sticas
        migrator.show_stats()
        
        # Aviso se foi dry-run
        if args.dry_run and migrator.stats["jobs_migrated"] > 0:
            print("\n‚ö†Ô∏è  DRY RUN - Nenhum dado foi alterado")
            print(f"   Execute com --execute para aplicar {migrator.stats['jobs_migrated']} migra√ß√µes")
        
    except redis.ConnectionError:
        print(f"‚ùå Erro: N√£o foi poss√≠vel conectar ao Redis ({args.host}:{args.port})")
        print("   Verifique se o Redis est√° rodando")
        sys.exit(1)
    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è  Migra√ß√£o cancelada pelo usu√°rio")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Erro inesperado: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
