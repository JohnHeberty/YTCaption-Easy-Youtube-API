"""
YouTube Downloader Implementation using yt-dlp.
Implementa√ß√£o concreta da interface IVideoDownloader.

v2.1: Retry logic com exponential backoff.
v2.2: Circuit breaker pr√≥prio integrado.
"""
import asyncio
import re
from pathlib import Path
from typing import Optional, Dict, Tuple
import yt_dlp
from loguru import logger
from tenacity import (
    retry,
    stop_after_attempt,
    wait_exponential,
    retry_if_exception_type,
    before_sleep_log
)

from src.domain.interfaces import IVideoDownloader
from src.domain.value_objects import YouTubeURL
from src.domain.entities import VideoFile
from src.domain.exceptions import VideoDownloadError, NetworkError, AudioTooLongError
from src.infrastructure.utils import CircuitBreaker, CircuitBreakerOpenError


# Circuit Breaker global para YouTube API
_youtube_circuit_breaker = CircuitBreaker(
    name="youtube_api",
    failure_threshold=5,
    timeout_seconds=60,
    half_open_max_calls=3
)


class YouTubeDownloader(IVideoDownloader):
    """
    Implementa√ß√£o de downloader do YouTube usando yt-dlp.
    Baixa v√≠deos na pior qualidade para otimizar extra√ß√£o de √°udio.
    """
    
    # Palavras-chave para detec√ß√£o de idioma
    LANGUAGE_KEYWORDS = {
        'pt': [
            'brasil', 'portuguese', 'portugu√™s', 'pt-br', 'legendado',
            'dublado', 'not√≠cias', 'reportagem', 'entrevista', 'programa',
            'epis√≥dio', 'temporada', 's√©rie'
        ],
        'en': [
            'english', 'subtitle', 'official', 'trailer', 'interview',
            'news', 'episode', 'season', 'series', 'documentary'
        ],
        'es': [
            'espa√±ol', 'spanish', 'latino', 'castellano', 'noticias',
            'entrevista', 'cap√≠tulo', 'temporada'
        ],
        'fr': [
            'fran√ßais', 'french', 'sous-titres', '√©pisode', 'saison'
        ],
        'de': [
            'deutsch', 'german', 'untertitel', 'folge', 'staffel'
        ],
        'it': [
            'italiano', 'italian', 'sottotitoli', 'episodio', 'stagione'
        ],
        'ja': [
            'japanese', 'Êó•Êú¨Ë™û', 'nihongo', 'anime', 'manga'
        ],
        'ko': [
            'korean', 'ÌïúÍµ≠Ïñ¥', 'hangul', 'k-pop', 'kdrama'
        ],
        'ru': [
            'russian', '—Ä—É—Å—Å–∫–∏–π', 'russkiy', '—Å—É–±—Ç–∏—Ç—Ä—ã'
        ],
        'zh': [
            'chinese', '‰∏≠Êñá', 'mandarin', 'cantonese'
        ]
    }
    
    # Caracteres especiais por idioma
    SPECIAL_CHARS = {
        'pt': '√†√°√¢√£√§√ß√®√©√™√´√¨√≠√Æ√Ø√≤√≥√¥√µ√∂√π√∫√ª√º√±',
        'es': '√°√©√≠√≥√∫√º√±¬ø¬°',
        'fr': '√†√¢√¶√ß√©√®√™√´√Ø√Æ√¥√π√ª√º√ø≈ì',
        'de': '√§√∂√º√ü·∫û',
        'it': '√†√®√©√¨√≠√Æ√≤√≥√π√∫',
        'ja': '„ÅÅ-„Çî„Ç°-„É¥„Éº„ÄÖ„ÄÜ„Ä§‰∏Ä-Èæ•',
        'ko': '„Ñ±-„Öé„Öè-„Ö£Í∞Ä-Ìû£',
        'ru': '–∞-—è–ê-–Ø—ë–Å',
        'zh': '‰∏Ä-Èæ•'
    }
    
    def __init__(
        self,
        output_template: str = "%(id)s.%(ext)s",
        max_filesize: Optional[int] = None,
        timeout: int = 300
    ):
        """
        Inicializa o downloader.
        
        Args:
            output_template: Template para nome do arquivo
            max_filesize: Tamanho m√°ximo do arquivo em bytes
            timeout: Timeout para download em segundos
        """
        self.output_template = output_template
        self.max_filesize = max_filesize
        self.timeout = timeout
    
    async def download(
        self, 
        url: YouTubeURL, 
        output_path: Path,
        validate_duration: bool = True,
        max_duration: Optional[int] = None
    ) -> VideoFile:
        """
        Baixa v√≠deo do YouTube na pior qualidade (focado em √°udio).
        
        v2.2: Circuit breaker custom + retry com exponential backoff.
        
        Args:
            url: URL do YouTube
            output_path: Diret√≥rio de sa√≠da
            validate_duration: Se deve validar a dura√ß√£o antes do download
            max_duration: Dura√ß√£o m√°xima permitida em segundos
            
        Returns:
            VideoFile: Arquivo de v√≠deo baixado
            
        Raises:
            VideoDownloadError: Se houver erro no download
            AudioTooLongError: Se v√≠deo exceder dura√ß√£o m√°xima
            CircuitBreakerOpenError: Se circuit breaker estiver aberto
        """
        # Envolve a l√≥gica de download com Circuit Breaker
        return await _youtube_circuit_breaker.call(self._download_internal, url, output_path, validate_duration, max_duration)
    
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=4, max=30),
        retry=retry_if_exception_type((yt_dlp.utils.DownloadError, ConnectionError, TimeoutError)),
        before_sleep=before_sleep_log(logger, logger.level("WARNING").no),
        reraise=True
    )
    async def _download_internal(
        self,
        url: YouTubeURL,
        output_path: Path,
        validate_duration: bool,
        max_duration: Optional[int]
    ) -> VideoFile:
        """M√©todo interno com retry logic - chamado pelo Circuit Breaker."""
        try:
            logger.info(f"üîΩ Starting download: {url.video_id}")
            
            # Validar dura√ß√£o antes de baixar (para v√≠deos longos)
            if validate_duration:
                info = await self.get_video_info(url)
                duration = info.get('duration', 0)
                
                if duration > 0:
                    duration_formatted = f"{duration//3600}h {(duration%3600)//60}m {duration%60}s"
                    logger.info(f"üìπ Video duration: {duration}s (~{duration_formatted})")
                    
                    if max_duration and duration > max_duration:
                        max_formatted = f"{max_duration//3600}h {(max_duration%3600)//60}m"
                        logger.error(
                            f"‚ùå Video too long: {duration}s > {max_duration}s"
                        )
                        # v2.1: Usar exce√ß√£o granular
                        raise AudioTooLongError(duration, max_duration)
                    
                    # Estimar tempo de processamento
                    estimated_processing = duration * 0.5  # Base model ~0.5x realtime
                    est_formatted = f"{int(estimated_processing//60)}m {int(estimated_processing%60)}s"
                    logger.info(f"‚è±Ô∏è  Estimated processing time: ~{est_formatted}")
            
            # Garantir que o diret√≥rio existe
            output_path.mkdir(parents=True, exist_ok=True)
            
            # Configura√ß√µes do yt-dlp para baixar pior qualidade (menor arquivo)
            ydl_opts = {
                'format': 'worstaudio/worst',  # Pior qualidade de √°udio/v√≠deo
                'outtmpl': str(output_path / self.output_template),
                'quiet': True,
                'no_warnings': True,
                'extract_flat': False,
                'socket_timeout': self.timeout,
                'nocheckcertificate': True,
                'prefer_insecure': True,
            }
            
            if self.max_filesize:
                ydl_opts['max_filesize'] = self.max_filesize
            
            # Executar download em thread separada para n√£o bloquear
            loop = asyncio.get_event_loop()
            info_dict = await loop.run_in_executor(
                None,
                self._download_sync,
                str(url),
                ydl_opts
            )
            
            # Criar entidade VideoFile
            file_path = Path(info_dict['filepath'])
            
            if not file_path.exists():
                raise VideoDownloadError(f"Downloaded file not found: {file_path}")
            
            video_file = VideoFile(
                file_path=file_path,
                original_url=str(url),
                file_size_bytes=file_path.stat().st_size,
                format=info_dict.get('ext', 'unknown')
            )
            
            logger.info(
                f"Download completed: {url.video_id} "
                f"({video_file.file_size_mb:.2f} MB)"
            )
            
            return video_file
            
        except AudioTooLongError:
            # Re-raise sem wrapper
            raise
        except yt_dlp.utils.DownloadError as e:
            logger.error(f"üî• yt-dlp download error: {str(e)}", exc_info=True)
            raise VideoDownloadError(f"Failed to download video: {str(e)}") from e
        except (ConnectionError, TimeoutError) as e:
            logger.error(f"üî• Network error during download: {str(e)}", exc_info=True)
            raise NetworkError("YouTube", str(e)) from e
        except Exception as e:
            logger.error(f"üî• Unexpected download error: {type(e).__name__}: {str(e)}", exc_info=True)
            raise VideoDownloadError(f"Unexpected error during download: {str(e)}") from e
    
    def _download_sync(self, url: str, ydl_opts: dict) -> dict:
        """
        Executa download s√≠ncrono.
        
        Args:
            url: URL do v√≠deo
            ydl_opts: Op√ß√µes do yt-dlp
            
        Returns:
            dict: Informa√ß√µes do v√≠deo baixado
        """
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=True)
            
            # Obter caminho do arquivo baixado
            if 'requested_downloads' in info and info['requested_downloads']:
                filepath = info['requested_downloads'][0]['filepath']
            else:
                filepath = ydl.prepare_filename(info)
            
            return {
                'filepath': filepath,
                'ext': info.get('ext', 'unknown'),
                'title': info.get('title', 'unknown'),
                'duration': info.get('duration', 0)
            }
    
    async def get_video_info(self, url: YouTubeURL) -> dict:
        """
        Obt√©m informa√ß√µes do v√≠deo sem baixar.
        
        v2.2: Circuit breaker custom + retry logic.
        
        Args:
            url: URL do YouTube
            
        Returns:
            dict: Informa√ß√µes do v√≠deo
            
        Raises:
            VideoDownloadError: Se houver erro ao obter informa√ß√µes
            CircuitBreakerOpenError: Se circuit breaker estiver aberto
        """
        # Envolve a l√≥gica de info com Circuit Breaker
        return await _youtube_circuit_breaker.call(self._get_video_info_internal, url)
    
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=2, max=10),
        retry=retry_if_exception_type((yt_dlp.utils.DownloadError, ConnectionError, TimeoutError)),
        before_sleep=before_sleep_log(logger, logger.level("WARNING").no),
        reraise=True
    )
    async def _get_video_info_internal(self, url: YouTubeURL) -> dict:
        """M√©todo interno com retry logic - chamado pelo Circuit Breaker."""
        try:
            logger.info(f"Fetching video info: {url.video_id}")
            
            ydl_opts = {
                'quiet': True,
                'no_warnings': True,
                'extract_flat': False,
                'socket_timeout': 30,
            }
            
            loop = asyncio.get_event_loop()
            info = await loop.run_in_executor(
                None,
                self._get_info_sync,
                str(url),
                ydl_opts
            )
            
            return {
                'video_id': info.get('id'),
                'title': info.get('title'),
                'duration': info.get('duration'),
                'description': info.get('description'),
                'uploader': info.get('uploader'),
                'upload_date': info.get('upload_date'),
                'view_count': info.get('view_count'),
                'formats_available': len(info.get('formats', []))
            }
            
        except yt_dlp.utils.DownloadError as e:
            logger.error(f"Failed to get video info: {str(e)}")
            raise VideoDownloadError(f"Failed to get video info: {str(e)}")
        except Exception as e:
            logger.error(f"Unexpected error getting video info: {str(e)}")
            raise VideoDownloadError(f"Unexpected error: {str(e)}")
    
    def _get_info_sync(self, url: str, ydl_opts: dict) -> dict:
        """
        Obt√©m informa√ß√µes s√≠ncronas do v√≠deo.
        
        Args:
            url: URL do v√≠deo
            ydl_opts: Op√ß√µes do yt-dlp
            
        Returns:
            dict: Informa√ß√µes do v√≠deo
        """
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            return ydl.extract_info(url, download=False)
    
    def detect_language_from_text(self, text: str) -> Tuple[str, float]:
        """
        Detecta o idioma baseado em an√°lise de texto.
        
        Args:
            text: Texto para an√°lise (t√≠tulo, descri√ß√£o, etc.)
            
        Returns:
            Tuple[str, float]: (c√≥digo do idioma, confian√ßa 0-1)
        """
        if not text:
            return 'unknown', 0.0
        
        text_lower = text.lower()
        scores = {}
        
        # Pontua√ß√£o por palavras-chave
        for lang, keywords in self.LANGUAGE_KEYWORDS.items():
            score = sum(1 for keyword in keywords if keyword in text_lower)
            if score > 0:
                scores[lang] = score
        
        # Pontua√ß√£o por caracteres especiais
        for lang, chars in self.SPECIAL_CHARS.items():
            pattern = f'[{chars}]'
            matches = len(re.findall(pattern, text, re.IGNORECASE))
            if matches > 0:
                scores[lang] = scores.get(lang, 0) + (matches * 0.5)
        
        if not scores:
            return 'unknown', 0.0
        
        # Calcular idioma com maior pontua√ß√£o
        max_lang = max(scores, key=scores.get)
        max_score = scores[max_lang]
        total_score = sum(scores.values())
        
        # Confian√ßa normalizada
        confidence = min(max_score / (total_score + 1), 1.0)
        
        return max_lang, round(confidence, 2)
    
    async def get_video_info_with_language(self, url: YouTubeURL) -> Dict:
        """
        Obt√©m informa√ß√µes do v√≠deo incluindo detec√ß√£o de idioma e legendas.
        
        Args:
            url: URL do YouTube
            
        Returns:
            Dict: Informa√ß√µes completas do v√≠deo
        """
        try:
            logger.info(f"Fetching detailed video info: {url.video_id}")
            
            ydl_opts = {
                'quiet': True,
                'no_warnings': True,
                'extract_flat': False,
                'socket_timeout': 30,
                'writesubtitles': True,
                'writeautomaticsub': True,
                'listsubtitles': True,
            }
            
            loop = asyncio.get_event_loop()
            info = await loop.run_in_executor(
                None,
                self._get_info_sync,
                str(url),
                ydl_opts
            )
            
            # Detectar idioma do texto
            text_to_analyze = f"{info.get('title', '')} {info.get('description', '')}"
            detected_lang, confidence = self.detect_language_from_text(text_to_analyze)
            
            # Extrair legendas dispon√≠veis
            subtitles = info.get('subtitles', {})
            automatic_captions = info.get('automatic_captions', {})
            
            # Formatar legendas
            available_subtitles = []
            for lang in subtitles.keys():
                available_subtitles.append({
                    'language': lang,
                    'type': 'manual',
                    'auto_generated': False
                })
            
            for lang in automatic_captions.keys():
                if lang not in subtitles:  # Evitar duplicatas
                    available_subtitles.append({
                        'language': lang,
                        'type': 'auto',
                        'auto_generated': True
                    })
            
            # Recomenda√ß√£o de modelo Whisper baseado na dura√ß√£o
            duration = info.get('duration', 0)
            whisper_recommendation = self._get_whisper_recommendation(duration)
            
            return {
                'video_id': info.get('id'),
                'title': info.get('title'),
                'duration': duration,
                'description': info.get('description'),
                'uploader': info.get('uploader'),
                'upload_date': info.get('upload_date'),
                'view_count': info.get('view_count'),
                'formats_available': len(info.get('formats', [])),
                'language_detection': {
                    'detected_language': detected_lang,
                    'confidence': confidence,
                    'method': 'text_analysis'
                },
                'available_subtitles': available_subtitles,
                'subtitle_languages': list(subtitles.keys()),
                'auto_caption_languages': list(automatic_captions.keys()),
                'whisper_recommendation': whisper_recommendation
            }
            
        except yt_dlp.utils.DownloadError as e:
            logger.error(f"Failed to get video info: {str(e)}")
            raise VideoDownloadError(f"Failed to get video info: {str(e)}")
        except Exception as e:
            logger.error(f"Unexpected error getting video info: {str(e)}")
            raise VideoDownloadError(f"Unexpected error: {str(e)}")
    
    def _get_whisper_recommendation(self, duration: int) -> Dict:
        """
        Recomenda modelo Whisper baseado na dura√ß√£o do v√≠deo.
        
        Args:
            duration: Dura√ß√£o em segundos
            
        Returns:
            Dict: Recomenda√ß√µes por modelo
        """
        models = {
            'tiny': {'speed': 32, 'quality': 'lowest'},
            'base': {'speed': 16, 'quality': 'low'},
            'small': {'speed': 6, 'quality': 'medium'},
            'medium': {'speed': 2, 'quality': 'high'},
            'large': {'speed': 1, 'quality': 'highest'}
        }
        
        recommendations = {}
        for model, config in models.items():
            estimated_time = duration / config['speed']
            recommendations[model] = {
                'estimated_time_seconds': int(estimated_time),
                'estimated_time_formatted': self._format_duration(int(estimated_time)),
                'quality': config['quality'],
                'recommended': model == 'base'  # Base como padr√£o
            }
        
        return recommendations
    
    def _format_duration(self, seconds: int) -> str:
        """Formata dura√ß√£o em formato leg√≠vel."""
        hours = seconds // 3600
        minutes = (seconds % 3600) // 60
        secs = seconds % 60
        
        if hours > 0:
            return f"{hours}h {minutes}m {secs}s"
        elif minutes > 0:
            return f"{minutes}m {secs}s"
        else:
            return f"{secs}s"

